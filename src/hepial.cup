import java.util.List;
import java.util.LinkedList;

parser code {:
    List<String> identifiers = new LinkedList<>();
    List<Type> params = new LinkedList<>();
    Function currentFunction = null;
:};

non terminal AXIOM, PROGRAM, HEADER, DECLARATION, DECLARATIONS, DECLAVAR, LIDENT, DECLACONST, DECLAFONCT, TYPE, TYPEBASE, ARRAY, DIM, PARAM, BODY, INSTR, INSTRUCTIONS, READ, WRITE, ASSIGNMENT, RETURN, CONDTITION, WHILE, FOR, EXPR, ACCESS, INDEX, OPERAND, OPEBIN, OPEUN, FUNCCALL, PAREFF, INDICES;
non terminal STARTFONC; // <- To avoid reduction conflicts
terminal t_beginPrg, t_endPrg, t_prg, t_semicolon, t_coma, t_const, t_eq, t_openpar, t_closepar, t_beginfunc, t_endfunc, t_int, t_bool, t_opensq, t_closesq, t_doubledot, t_read, t_write, t_string, t_return, t_if, t_then, t_else, t_endif, t_while, t_do, t_endwhile, t_for, t_from, t_to, t_endfor, t_true, t_false, t_plus, t_minus, t_time, t_div, t_doubleq, t_diff, t_lt, t_gt, t_le, t_ge, t_and, t_or, t_notn, t_not;
terminal int t_intConst;
terminal String t_ident;

precedence left t_plus, t_minus, t_time, t_div, t_doubleq, t_diff;
precedence left t_lt, t_gt, t_le, t_ge, t_and, t_or, t_doubledot;
precedence right t_notn, t_not;

AXIOM ::= PROGRAM {:
    System.out.println(SymbolTable.getInstance());
:};

PROGRAM ::= HEADER DECLARATIONS t_beginPrg BODY t_endPrg;

HEADER ::= t_prg t_ident;

DECLARATIONS ::= DECLARATION DECLARATIONS |;
DECLARATION ::= DECLAVAR | DECLACONST | DECLAFONCT;

DECLAVAR ::= TYPE:t LIDENT:lid t_semicolon {:
    for(String str : identifiers) {
        SymbolTable.getInstance().add(new Entry(str), new Variable((Type)t, SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    identifiers.clear();
:};

LIDENT ::= t_ident:t {: identifiers.add(t); :} | t_ident:t t_coma LIDENT {: identifiers.add(t); :};

DECLACONST ::= t_const TYPE:t t_ident:name t_eq EXPR t_semicolon {:
    if(t == Type.INTEGER) {
        SymbolTable.getInstance().add(new Entry((String)name), new IntConst(SymbolTable.getInstance().getBloc(), HepialF.line));
    } else if(t == Type.BOOLEAN) {
        SymbolTable.getInstance().add(new Entry((String)name), new BoolConst(SymbolTable.getInstance().getBloc(), HepialF.line));
    }
:};

STARTFONC ::= TYPE:rt t_ident:name t_openpar {:
    currentFunction = new Function((Type)rt, HepialF.line);
    SymbolTable.getInstance().add(new Entry((String)name), currentFunction);
    SymbolTable.getInstance().enterBlock();
:};

DECLAFONCT ::=  STARTFONC PARAM t_closepar DECLARATIONS t_beginfunc BODY t_endfunc {:
    currentFunction.getParams().addAll(params);
    SymbolTable.getInstance().exitBlock();
:};

DECLAFONCT ::= STARTFONC t_closepar DECLARATIONS t_beginfunc BODY t_endfunc {:
    SymbolTable.getInstance().exitBlock();
:};

TYPE ::= TYPEBASE:t {:
    RESULT = t;
:};

TYPE ::= ARRAY:t {:
    RESULT = t;
:};

TYPEBASE ::= t_int:t  {: RESULT = Type.INTEGER; :} | t_bool:t  {: RESULT = Type.BOOLEAN; :};

ARRAY ::= TYPEBASE:t t_opensq DIM t_closesq {:
    if((Type)t == Type.INTEGER) {
        RESULT = Type.INTEGERARRAY;
    } else if((Type)t == Type.BOOLEAN) {
        RESULT = Type.BOOLEANARRAY;
    }
:};

DIM ::= EXPR t_doubledot EXPR | DIM t_coma EXPR t_doubledot EXPR;

PARAM ::= TYPE:t t_ident:name {: params.add((Type)t); SymbolTable.getInstance().add(new Entry((String)name), new Variable((Type)t, SymbolTable.getInstance().getBloc(), HepialF.line)); :}
| PARAM t_coma TYPE:t t_ident:name {: params.add((Type)t); SymbolTable.getInstance().add(new Entry((String)name), new Variable((Type)t, SymbolTable.getInstance().getBloc(), HepialF.line)); :};

BODY ::= INSTRUCTIONS;
INSTRUCTIONS ::= INSTR INSTRUCTIONS |;
INSTR ::= ASSIGNMENT | WRITE | READ | CONDTITION | RETURN | WHILE | FOR;

READ ::= t_read t_ident t_semicolon;

WRITE ::= t_write EXPR t_semicolon | t_write t_string t_semicolon;

ASSIGNMENT ::= ACCESS t_eq EXPR t_semicolon;

RETURN ::= t_return EXPR t_semicolon;

CONDTITION ::= t_if EXPR t_then BODY t_else BODY t_endif;

WHILE ::= t_while EXPR t_do BODY t_endwhile;

FOR ::= t_for t_ident t_from EXPR t_to EXPR t_do BODY t_endfor;

EXPR ::= EXPR OPEBIN EXPR | OPEUN EXPR | t_openpar EXPR t_closepar | OPERAND;

ACCESS ::= t_ident | t_ident INDICES;

INDICES ::= INDEX INDICES | INDEX;
INDEX ::= t_opensq EXPR t_closesq;

OPERAND ::= ACCESS | FUNCCALL | t_intConst | t_true | t_false;

OPEBIN ::= t_plus | t_minus | t_time | t_div | t_doubleq | t_diff | t_lt | t_gt | t_le | t_ge | t_and | t_or;

OPEUN ::= t_not | t_notn;

FUNCCALL ::= t_ident t_openpar t_closepar | t_ident t_openpar PAREFF t_closepar;

PAREFF ::= EXPR | PAREFF t_coma EXPR;
