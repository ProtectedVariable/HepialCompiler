import java.util.List;
import java.util.LinkedList;

parser code {:
    List<String> identifiers = new LinkedList<>();
    List<Type> params = new LinkedList<>();
:};

non terminal AXIOM, PROGRAM, HEADER, DECLARATION, DECLARATIONS, DECLAVAR, LIDENT, DECLACONST, DECLAFONCT, TYPE, TYPEBASE, ARRAY, DIM, PARAM, BODY, INSTR, INSTRUCTIONS, READ, WRITE, ASSIGNMENT, RETURN, CONDTITION, WHILE, FOR, EXPR, ACCESS, INDEX, OPERAND, OPEBIN, OPEUN, FUNCCALL, PAREFF, INDICES;
terminal t_beginPrg, t_endPrg, t_prg, t_semicolon, t_coma, t_const, t_eq, t_openpar, t_closepar, t_beginfunc, t_endfunc, t_int, t_bool, t_opensq, t_closesq, t_doubledot, t_read, t_write, t_string, t_return, t_if, t_then, t_else, t_endif, t_while, t_do, t_endwhile, t_for, t_from, t_to, t_endfor, t_true, t_false, t_plus, t_minus, t_time, t_div, t_doubleq, t_diff, t_lt, t_gt, t_le, t_ge, t_and, t_or, t_notn, t_not;
terminal int t_intConst;
terminal String t_ident;

precedence left t_plus, t_minus, t_time, t_div, t_doubleq, t_diff;
precedence left t_lt, t_gt, t_le, t_ge, t_and, t_or, t_doubledot;
precedence right t_notn, t_not;

AXIOM ::= PROGRAM {:
    System.out.println(SymbolTable.getInstance());
:};

PROGRAM ::= HEADER t_beginPrg BODY t_endPrg;
PROGRAM ::= HEADER DECLARATIONS t_beginPrg BODY t_endPrg;

HEADER ::= t_prg t_ident;

DECLARATIONS ::= DECLARATION DECLARATIONS | DECLARATION;
DECLARATION ::= DECLAVAR | DECLACONST | DECLAFONCT;

DECLAVAR ::= TYPE:t LIDENT:lid t_semicolon {:
    for(String str : identifiers) {
        SymbolTable.getInstance().add(new Entry(str), new Variable((Type)t, SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    identifiers.clear();
:};

LIDENT ::= t_ident:t {: identifiers.add(t); :} | t_ident:t t_coma LIDENT {: identifiers.add(t); :};

DECLACONST ::= t_const TYPE:t t_ident:name t_eq EXPR t_semicolon {:
    if(t == Type.INTEGER) {
        SymbolTable.getInstance().add(new Entry((String)name), new IntConst(SymbolTable.getInstance().getBloc(), HepialF.line));
    } else if(t == Type.BOOLEAN) {
        SymbolTable.getInstance().add(new Entry((String)name), new BoolConst(SymbolTable.getInstance().getBloc(), HepialF.line));
    }
:};

DECLAFONCT ::= TYPE:rt t_ident:name t_openpar PARAM t_closepar DECLARATIONS t_beginfunc BODY t_endfunc {:
    SymbolTable.getInstance().enterBlock();
    System.out.println(params.size()+" "+identifiers.size());
    for(int i = 0; i < params.size(); i++) {
        SymbolTable.getInstance().add(new Entry(identifiers.get(i)), new Variable(params.get(i), SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    SymbolTable.getInstance().exitBlock();
    SymbolTable.getInstance().add(new Entry((String)name), new Function(params, (Type)rt, HepialF.line));
    params.clear();
    identifiers.clear();
:};

DECLAFONCT ::= TYPE:rt t_ident:name t_openpar PARAM t_closepar t_beginfunc BODY t_endfunc {:
    SymbolTable.getInstance().enterBlock();
    for(int i = 0; i < params.size(); i++) {
        SymbolTable.getInstance().add(new Entry(identifiers.get(i)), new Variable(params.get(i), SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    SymbolTable.getInstance().exitBlock();
    SymbolTable.getInstance().add(new Entry((String)name), new Function(params, (Type)rt, HepialF.line));
    params.clear();
    identifiers.clear();
:};

DECLAFONCT ::= TYPE:rt t_ident:name t_openpar t_closepar DECLARATIONS t_beginfunc BODY t_endfunc {:
    SymbolTable.getInstance().enterBlock();
    for(int i = 0; i < params.size(); i++) {
        SymbolTable.getInstance().add(new Entry(identifiers.get(i)), new Variable(params.get(i), SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    SymbolTable.getInstance().exitBlock();
    SymbolTable.getInstance().add(new Entry((String)name), new Function(params, (Type)rt, HepialF.line));
    params.clear();
    identifiers.clear();
:};

DECLAFONCT ::= TYPE:rt t_ident:name t_openpar t_closepar t_beginfunc BODY t_endfunc {:
    SymbolTable.getInstance().enterBlock();
    for(int i = 0; i < params.size(); i++) {
        SymbolTable.getInstance().add(new Entry(identifiers.get(i)), new Variable(params.get(i), SymbolTable.getInstance().getBloc(), HepialF.line));
    }
    SymbolTable.getInstance().exitBlock();
    SymbolTable.getInstance().add(new Entry((String)name), new Function(params, (Type)rt, HepialF.line));
    params.clear();
    identifiers.clear();
:};

TYPE ::= TYPEBASE:t {:
    RESULT = t;
:};

TYPE ::= ARRAY:t {:
    RESULT = t;
:};

TYPEBASE ::= t_int:t  {: RESULT = Type.INTEGER; :} | t_bool:t  {: RESULT = Type.BOOLEAN; :};

ARRAY ::= TYPEBASE:t t_opensq DIM t_closesq {:
    if((Type)t == Type.INTEGER) {
        RESULT = Type.INTEGERARRAY;
    } else if((Type)t == Type.BOOLEAN) {
        RESULT = Type.BOOLEANARRAY;
    }
:};

DIM ::= EXPR t_doubledot EXPR | DIM t_coma EXPR t_doubledot EXPR;

PARAM ::= TYPE:t t_ident:name {: params.add((Type)t); identifiers.add(name); :}  | PARAM t_coma TYPE:t t_ident:name {: params.add((Type)t); identifiers.add(name); :};

BODY ::= INSTRUCTIONS;
//TODO allow no instr (* instead of +)
INSTRUCTIONS ::= INSTR INSTRUCTIONS | INSTR;
INSTR ::= ASSIGNMENT | WRITE | READ | CONDTITION | RETURN | WHILE | FOR;

READ ::= t_read t_ident t_semicolon;

WRITE ::= t_write EXPR t_semicolon | t_write t_string t_semicolon;

ASSIGNMENT ::= ACCESS t_eq EXPR t_semicolon;

RETURN ::= t_return EXPR t_semicolon;

CONDTITION ::= t_if EXPR t_then BODY t_else BODY t_endif;

WHILE ::= t_while EXPR t_do BODY t_endwhile;

FOR ::= t_for t_ident t_from EXPR t_to EXPR t_do BODY t_endfor;

EXPR ::= EXPR OPEBIN EXPR | OPEUN EXPR | t_openpar EXPR t_closepar | OPERAND;

ACCESS ::= t_ident | t_ident INDICES;

INDICES ::= INDEX INDICES | INDEX;
INDEX ::= t_opensq EXPR t_closesq;

OPERAND ::= ACCESS | FUNCCALL | t_intConst | t_true | t_false;

OPEBIN ::= t_plus | t_minus | t_time | t_div | t_doubleq | t_diff | t_lt | t_gt | t_le | t_ge | t_and | t_or;

OPEUN ::= t_not | t_notn;

FUNCCALL ::= t_ident t_openpar t_closepar | t_ident t_openpar PAREFF t_closepar;

PAREFF ::= EXPR | PAREFF t_coma EXPR;
